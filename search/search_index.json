{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Analysis Correlation Engine \u00b6 If you're looking to just try this out, just down to the quick start guide on this page to see what this system is capable of. If you're an analyst and you want to add something new to ACE, then look here. The Somewhat Long-winded Description of ACE \u00b6 The Analysis Correlation Engine (ACE) is a recursive analysis engine geared towards cyber security. You submit stuff, the stuff you submit gets analyzed, and then you get a result back. Most of the time there are already certain things you know about what you're submitting. You've probably already analyzed the thing you're submitting, and as part of that analysis , you've made some observations . In ACE we take that idea and build on it, and we give names to specific parts of the idea. The \"thing\" we're submitting is called a Root Analysis . It's essentially a container for all the stuff we want to analyze. All the things we've already observed that we understand we identify as Observables . Each observable has a type (such as username, ip address, or file name), a value, and maybe a time recorded for the observation. And then, naturally, that thing you observed has be analyzed. When you analyze something, you produce some kind of a result, or at least draw some kind of a conclusion. Usually you're trying to answer a question you need to have answered before you can move on to the next thing. For example, if you have observed an ip address in your environment, you might want to answer the question of \"Does this IP address exist in that list of IP addresses my intelligence team gave me last week?\" We call the output of analyzing an observable an Analysis . And then, as a part of doing this additional analysis, you might make more observations. For example, you might actually find that the ip address was actually in that list you were looking at, so you would say that you have observed a suspect ip address interacting with your environment. In ACE, an Analysis can produce additional Observables , which can also be analyzed. The next step would be to search in all of your logs for any occurrence of this ip address to see if anyone in your environment interacted with it around the time the original observation was made. If you found something, say a user browsed to a site hosted on the ip address through your corporate proxy, then you might want to spend your precious time on that ! In ACE we would add a Detection to the observation of the url that was used to access the suspect site hosted on the suspect ip address. And then any Root Analysis with at least one Detection ends up turning into an Alert that gets sent to an Alert Management System analysts can use to really dive into the details of what happened. TL;DR \u00b6 ACE defines very basic data types which it uses to recursively analyze data. Something is submitted to ACE for analysis. We call this something a Root Analysis . Observations are made on the analysis . Those observations are also analyzed producing additional analysis until all observations are analyzed. Analysis is performed by analysis modules . An alert is created by adding a detection to an observation or analysis. Alerts are submitted to an alert management system for review. ACE uses free-form JSON data structures to represent the results of analysis. Why ACE? \u00b6 Good question. There's a lot of stuff in the cyber security world that you can use for this. Here are some of the strengths and weaknesses of this one. Strengths \u00b6 Alert enrichment: ACE can be used to enrich existing alert data, hopefully cutting down the time it takes an analyst to come to a conclusion on any given alert. Detection: The same engine that enriches alerts can also be used as a generic detection engine. Throw stuff at it that you're not sure about, it'll alert if it finds something. Email Scanning: ACE has special support built-in for scanning your corporate email as it's delivered to your user's mailboxes. This gives you a real shot at stopping some of the most popular attacks we've been seeing, without risking blocking legitimate emails. Extendable: ACE has be easily extended to add additional functionality. As a matter of fact, this was one of the primary focus points of the design of the entire system. Analysts with even basic programming skills can add new capabilities to the system without having an administrator worry about the impact to it. Scalable - The design of the system is super scalable. If you find you're system falling behind, you can just spin up ACE on another system and hook it up with a few commands. Usable - If you're an analyst, you can just use it on your own. You really don't need someone to do a full deployment for you in order to use it. Tooling - The tools are built with a Unix design philosophy in mind, meaning you can run ACE as part of a chain of commands tied together with pipes. Weaknesses \u00b6 Like nobody is using it yet. Only a few people support it so far. You need someone with some decent IT skills to run it for a team. It's not a point-and-click kind of thing. You probably still need to build all the integration with all the random stuff your company runs that this project probably doesn't support yet. But if you do that, maybe consider joining the project! Quick Start \u00b6 # # let's analyze something right now # # requires python3.9 python3.9 -m venv .venv source .venv/bin/activate # this installs everything at once pip install ace2[all] # install the packages we know about # this connects to our public github page and gets the list of all the known packages # it can also use the env var ACE_PACKAGE_URI to get a different custom list ace2 package install --all # now analyze that suspicious file your boss's boss sent your boss who sent it to you ace2 analyze file email_attachment.doc # or a URL ace2 analyze url http://bit.ly/blahblah # or an IP (v4) address ace2 analyze ipv4 8.8.4.4 Advanced Usage \u00b6 # # here's some more stuff you can do # # we could install packages manually # directly from github ace2 package install ace2 package install git@github.com:ace-ecosystem/ace2-modules.git # or from a url ace2 package install ace2 package install http://someserver.com/ace2-package.zip # or from a local zip file you downloaded with curl ace2 package install ace2 package install /path/to/ace2-package.zip # make sure all the packages are up to date # this also updates all the modules ace2 package update # could also do this to just update modules (signatures and such) # for the ones that support it ace2 module update # now I can see what packages I have installed ace2 package list # and even see what modules I have available # from all the packages I have installed ace2 module list # and what services I can start ace2 service list # # PARTICIPATING IN A CORE # # a little more advanced usage here # specify the core to connect to export ACE_URI=\"https://ace2.local/\" export ACE_API_KEY=\"6a36ffce-507e-469f-8d68-39ca00fa9ccb\" # attach all the modules we have on this system to the remote core # and start processing requests # this is an example of how to scale (manually anyways) ace2 service start manager # # REMOTE USAGE OF A CORE # # now this command uses the remote core # since we have our env vars set up ace2 analyze ipv4 3.127.0.4 # this lists the analysis modules of the remote core ace2 module list # # PRODUCTION COMMANDS # # start a production core system docker-compose -f ace2-core.yml # start containers that run the modules docker-compose -f ace2-modules.yml # more to come as development continues...","title":"Analysis Correlation Engine"},{"location":"#analysis-correlation-engine","text":"If you're looking to just try this out, just down to the quick start guide on this page to see what this system is capable of. If you're an analyst and you want to add something new to ACE, then look here.","title":"Analysis Correlation Engine"},{"location":"#the-somewhat-long-winded-description-of-ace","text":"The Analysis Correlation Engine (ACE) is a recursive analysis engine geared towards cyber security. You submit stuff, the stuff you submit gets analyzed, and then you get a result back. Most of the time there are already certain things you know about what you're submitting. You've probably already analyzed the thing you're submitting, and as part of that analysis , you've made some observations . In ACE we take that idea and build on it, and we give names to specific parts of the idea. The \"thing\" we're submitting is called a Root Analysis . It's essentially a container for all the stuff we want to analyze. All the things we've already observed that we understand we identify as Observables . Each observable has a type (such as username, ip address, or file name), a value, and maybe a time recorded for the observation. And then, naturally, that thing you observed has be analyzed. When you analyze something, you produce some kind of a result, or at least draw some kind of a conclusion. Usually you're trying to answer a question you need to have answered before you can move on to the next thing. For example, if you have observed an ip address in your environment, you might want to answer the question of \"Does this IP address exist in that list of IP addresses my intelligence team gave me last week?\" We call the output of analyzing an observable an Analysis . And then, as a part of doing this additional analysis, you might make more observations. For example, you might actually find that the ip address was actually in that list you were looking at, so you would say that you have observed a suspect ip address interacting with your environment. In ACE, an Analysis can produce additional Observables , which can also be analyzed. The next step would be to search in all of your logs for any occurrence of this ip address to see if anyone in your environment interacted with it around the time the original observation was made. If you found something, say a user browsed to a site hosted on the ip address through your corporate proxy, then you might want to spend your precious time on that ! In ACE we would add a Detection to the observation of the url that was used to access the suspect site hosted on the suspect ip address. And then any Root Analysis with at least one Detection ends up turning into an Alert that gets sent to an Alert Management System analysts can use to really dive into the details of what happened.","title":"The Somewhat Long-winded Description of ACE"},{"location":"#tldr","text":"ACE defines very basic data types which it uses to recursively analyze data. Something is submitted to ACE for analysis. We call this something a Root Analysis . Observations are made on the analysis . Those observations are also analyzed producing additional analysis until all observations are analyzed. Analysis is performed by analysis modules . An alert is created by adding a detection to an observation or analysis. Alerts are submitted to an alert management system for review. ACE uses free-form JSON data structures to represent the results of analysis.","title":"TL;DR"},{"location":"#why-ace","text":"Good question. There's a lot of stuff in the cyber security world that you can use for this. Here are some of the strengths and weaknesses of this one.","title":"Why ACE?"},{"location":"#strengths","text":"Alert enrichment: ACE can be used to enrich existing alert data, hopefully cutting down the time it takes an analyst to come to a conclusion on any given alert. Detection: The same engine that enriches alerts can also be used as a generic detection engine. Throw stuff at it that you're not sure about, it'll alert if it finds something. Email Scanning: ACE has special support built-in for scanning your corporate email as it's delivered to your user's mailboxes. This gives you a real shot at stopping some of the most popular attacks we've been seeing, without risking blocking legitimate emails. Extendable: ACE has be easily extended to add additional functionality. As a matter of fact, this was one of the primary focus points of the design of the entire system. Analysts with even basic programming skills can add new capabilities to the system without having an administrator worry about the impact to it. Scalable - The design of the system is super scalable. If you find you're system falling behind, you can just spin up ACE on another system and hook it up with a few commands. Usable - If you're an analyst, you can just use it on your own. You really don't need someone to do a full deployment for you in order to use it. Tooling - The tools are built with a Unix design philosophy in mind, meaning you can run ACE as part of a chain of commands tied together with pipes.","title":"Strengths"},{"location":"#weaknesses","text":"Like nobody is using it yet. Only a few people support it so far. You need someone with some decent IT skills to run it for a team. It's not a point-and-click kind of thing. You probably still need to build all the integration with all the random stuff your company runs that this project probably doesn't support yet. But if you do that, maybe consider joining the project!","title":"Weaknesses"},{"location":"#quick-start","text":"# # let's analyze something right now # # requires python3.9 python3.9 -m venv .venv source .venv/bin/activate # this installs everything at once pip install ace2[all] # install the packages we know about # this connects to our public github page and gets the list of all the known packages # it can also use the env var ACE_PACKAGE_URI to get a different custom list ace2 package install --all # now analyze that suspicious file your boss's boss sent your boss who sent it to you ace2 analyze file email_attachment.doc # or a URL ace2 analyze url http://bit.ly/blahblah # or an IP (v4) address ace2 analyze ipv4 8.8.4.4","title":"Quick Start"},{"location":"#advanced-usage","text":"# # here's some more stuff you can do # # we could install packages manually # directly from github ace2 package install ace2 package install git@github.com:ace-ecosystem/ace2-modules.git # or from a url ace2 package install ace2 package install http://someserver.com/ace2-package.zip # or from a local zip file you downloaded with curl ace2 package install ace2 package install /path/to/ace2-package.zip # make sure all the packages are up to date # this also updates all the modules ace2 package update # could also do this to just update modules (signatures and such) # for the ones that support it ace2 module update # now I can see what packages I have installed ace2 package list # and even see what modules I have available # from all the packages I have installed ace2 module list # and what services I can start ace2 service list # # PARTICIPATING IN A CORE # # a little more advanced usage here # specify the core to connect to export ACE_URI=\"https://ace2.local/\" export ACE_API_KEY=\"6a36ffce-507e-469f-8d68-39ca00fa9ccb\" # attach all the modules we have on this system to the remote core # and start processing requests # this is an example of how to scale (manually anyways) ace2 service start manager # # REMOTE USAGE OF A CORE # # now this command uses the remote core # since we have our env vars set up ace2 analyze ipv4 3.127.0.4 # this lists the analysis modules of the remote core ace2 module list # # PRODUCTION COMMANDS # # start a production core system docker-compose -f ace2-core.yml # start containers that run the modules docker-compose -f ace2-modules.yml # more to come as development continues...","title":"Advanced Usage"},{"location":"admin/","text":"ACE Administration Guide \u00b6 This documentation is written for someone who is running a full ACE deployment. If you just want to use ACE to analyze something (quickly) then look here instead . Jump to the quick start guide if you're like me and don't want to read a bunch of stuff you might not ever need to know. Getting Started Quick start guide. Installation Deciding how to run ACE. First Time Setup Understanding ACE packages Configuration settings. Encryption settings. API keys and authentication. Security considerations. Running ACE Startup Monitoring Logging Management Shutdown Maintenance Upgrading Debugging Extending ACE Understanding the design of ACE. Adding new modules. Scaling ACE Adding new core capacity. Adding new analysis capacity. Extending storage capacity. Relational and document database considerations.","title":"ACE Administration Guide"},{"location":"admin/#ace-administration-guide","text":"This documentation is written for someone who is running a full ACE deployment. If you just want to use ACE to analyze something (quickly) then look here instead . Jump to the quick start guide if you're like me and don't want to read a bunch of stuff you might not ever need to know. Getting Started Quick start guide. Installation Deciding how to run ACE. First Time Setup Understanding ACE packages Configuration settings. Encryption settings. API keys and authentication. Security considerations. Running ACE Startup Monitoring Logging Management Shutdown Maintenance Upgrading Debugging Extending ACE Understanding the design of ACE. Adding new modules. Scaling ACE Adding new core capacity. Adding new analysis capacity. Extending storage capacity. Relational and document database considerations.","title":"ACE Administration Guide"},{"location":"core/","text":"Core System \u00b6 ACE is composed of subsystem component interfaces. Each interface allows implementation of a particular part of the system. An implementation of all of these interfaces would create a complete ACE core system . System Interfaces \u00b6 The following interfaces make up the entirety of the ACE system: Alerting Analysis Tracking Caching Configuration Events Locking Analysis Module Tracking Observables Analysis Request Tracking Storage Work Queues Process Workflow \u00b6 Overview \u00b6 The following is a basic high level overview of the fundamental logic of the analysis system: Register one or more analysis modules. Submit a new analysis request. New analysis requests are added to the work queues based on the content of the submission. Analysis modules pull requests from the work queues. Analysis modules post results of the analysis. New analysis requests are added to the work queues based on the content of the posted results. Process continues until work queues are emptied. Analysis Module Registration \u00b6 The process begins by registering one or more analysis modules . A module registration informs the system what type of data the module is interested in analyzing. A registered analysis module is registered under a type name and each analysis module type is assigned its own work queue that receives analysis requests specific to that module type . This part of the process is external to the core system. Analysis Request Submission \u00b6 Work is initiated by submitting a root analysis request to the system. An initial request supplies the root analysis object along with any observables that should be analyzed by the system. Analysis Request Processing \u00b6 The ACE core system processes inbound analysis requests by enumerating all observables in the root analysis object and cross-referencing that with all registered analysis modules . An observable is assigned to a module for analysis by creating a new observable analysis request and appending that request to the work queue assigned to that analysis module type. Analysis modules then receive the request by acquiring the next work item from their assigned work queues . Analysis Module Execution \u00b6 Each analysis module receives observable analysis requests through the work queue which is assigned to the analysis module type . The execution of the analysis module logic is external to the core engine. Analysis Result Processing \u00b6 The results of the analysis are posted back to the ACE core system as observable analysis results . These results contain the original request as well as the result of the analysis. The ACE core system applies any changes generated by the analysis back to the root analysis object. Any new observables found in the results generate new analysis requests if they have not yet been analyzed. This recursion continues until all observables have been analyzed by all registered analysis modules. Alerting \u00b6 At any point during processing any root analysis that has one or more detection points is automatically passed to the alert interface for processing.","title":"Core System"},{"location":"core/#core-system","text":"ACE is composed of subsystem component interfaces. Each interface allows implementation of a particular part of the system. An implementation of all of these interfaces would create a complete ACE core system .","title":"Core System"},{"location":"core/#system-interfaces","text":"The following interfaces make up the entirety of the ACE system: Alerting Analysis Tracking Caching Configuration Events Locking Analysis Module Tracking Observables Analysis Request Tracking Storage Work Queues","title":"System Interfaces"},{"location":"core/#process-workflow","text":"","title":"Process Workflow"},{"location":"core/#overview","text":"The following is a basic high level overview of the fundamental logic of the analysis system: Register one or more analysis modules. Submit a new analysis request. New analysis requests are added to the work queues based on the content of the submission. Analysis modules pull requests from the work queues. Analysis modules post results of the analysis. New analysis requests are added to the work queues based on the content of the posted results. Process continues until work queues are emptied.","title":"Overview"},{"location":"core/#analysis-module-registration","text":"The process begins by registering one or more analysis modules . A module registration informs the system what type of data the module is interested in analyzing. A registered analysis module is registered under a type name and each analysis module type is assigned its own work queue that receives analysis requests specific to that module type . This part of the process is external to the core system.","title":"Analysis Module Registration"},{"location":"core/#analysis-request-submission","text":"Work is initiated by submitting a root analysis request to the system. An initial request supplies the root analysis object along with any observables that should be analyzed by the system.","title":"Analysis Request Submission"},{"location":"core/#analysis-request-processing","text":"The ACE core system processes inbound analysis requests by enumerating all observables in the root analysis object and cross-referencing that with all registered analysis modules . An observable is assigned to a module for analysis by creating a new observable analysis request and appending that request to the work queue assigned to that analysis module type. Analysis modules then receive the request by acquiring the next work item from their assigned work queues .","title":"Analysis Request Processing"},{"location":"core/#analysis-module-execution","text":"Each analysis module receives observable analysis requests through the work queue which is assigned to the analysis module type . The execution of the analysis module logic is external to the core engine.","title":"Analysis Module Execution"},{"location":"core/#analysis-result-processing","text":"The results of the analysis are posted back to the ACE core system as observable analysis results . These results contain the original request as well as the result of the analysis. The ACE core system applies any changes generated by the analysis back to the root analysis object. Any new observables found in the results generate new analysis requests if they have not yet been analyzed. This recursion continues until all observables have been analyzed by all registered analysis modules.","title":"Analysis Result Processing"},{"location":"core/#alerting","text":"At any point during processing any root analysis that has one or more detection points is automatically passed to the alert interface for processing.","title":"Alerting"},{"location":"core/alerting/","text":"Alerting \u00b6 An alert is created when a root is found to contain one or more detection points when processing analysis requests. Alerts are tracked through the ace.system.alerting.AlertTrackingInterface . Alerts are simply references to RootAnalysis objects. Alert Systems \u00b6 Alerts are collected and managed by other systems called alert management systems . These systems allow an analyst to visually analyze alert data and respond to the results. Alert collection is performed in two steps. Registration of the alert management system. Periodic queries for alert data. Alert System Registration \u00b6 An system that wishes to collect alerts must first register itself with the core by calling register_alert_system with a name that is unique to the system. The core will then create a queue for the registered systems. Every generated alert will be stored in the queue until it is collected by the alert management system. There is no limitation to the size of the queue. Multiple alert management systems can be registered in this way. Alert Collection \u00b6 The alert system can get call get_alerts to collect any alerts that have been generated by the core. There are two ways to continuously collect alerts. Waiting For Events \u00b6 An alert system can subscribe to the alert event and then issue a collection request upon receiving the event. Waiting for Alerts \u00b6 An alert system can use the optional timeout parameter to get_alerts which will block until an alert is available, and then return that alert. If no alert becomes available during the waiting period, then an empty list is returned, and then the alert system tries again.","title":"Alerting"},{"location":"core/alerting/#alerting","text":"An alert is created when a root is found to contain one or more detection points when processing analysis requests. Alerts are tracked through the ace.system.alerting.AlertTrackingInterface . Alerts are simply references to RootAnalysis objects.","title":"Alerting"},{"location":"core/alerting/#alert-systems","text":"Alerts are collected and managed by other systems called alert management systems . These systems allow an analyst to visually analyze alert data and respond to the results. Alert collection is performed in two steps. Registration of the alert management system. Periodic queries for alert data.","title":"Alert Systems"},{"location":"core/alerting/#alert-system-registration","text":"An system that wishes to collect alerts must first register itself with the core by calling register_alert_system with a name that is unique to the system. The core will then create a queue for the registered systems. Every generated alert will be stored in the queue until it is collected by the alert management system. There is no limitation to the size of the queue. Multiple alert management systems can be registered in this way.","title":"Alert System Registration"},{"location":"core/alerting/#alert-collection","text":"The alert system can get call get_alerts to collect any alerts that have been generated by the core. There are two ways to continuously collect alerts.","title":"Alert Collection"},{"location":"core/alerting/#waiting-for-events","text":"An alert system can subscribe to the alert event and then issue a collection request upon receiving the event.","title":"Waiting For Events"},{"location":"core/alerting/#waiting-for-alerts","text":"An alert system can use the optional timeout parameter to get_alerts which will block until an alert is available, and then return that alert. If no alert becomes available during the waiting period, then an empty list is returned, and then the alert system tries again.","title":"Waiting for Alerts"},{"location":"core/analysis_module_tracking/","text":"Analysis Module Tracking \u00b6 Analysis modules are tracked as analysis module types through the interface ace.system.analysis_module_tracking.AnalysisModuleTrackingInterface . Analysis modules start by registering with the system. Multiple instances of the same analysis module can register as long as the version of the module remains the same. This keeps track of what analysis modules have been registered and which ones have not expired or been invalidated. Each analysis module type is assigned a work queue. Any work created that the analysis module supports is assigned to the work queue. Any instance of the analysis module can pick up the work from the queue. When an analysis module requests work, it also submits its current version data so that it can be checked against the registered analysis module. Versions \u00b6 Every analysis module type has a version , which is defined by a number of properties. When an analysis module registers a new version, the new type replaces the old type. Any attempts to acquire work with the old version are denied.","title":"Analysis Module Tracking"},{"location":"core/analysis_module_tracking/#analysis-module-tracking","text":"Analysis modules are tracked as analysis module types through the interface ace.system.analysis_module_tracking.AnalysisModuleTrackingInterface . Analysis modules start by registering with the system. Multiple instances of the same analysis module can register as long as the version of the module remains the same. This keeps track of what analysis modules have been registered and which ones have not expired or been invalidated. Each analysis module type is assigned a work queue. Any work created that the analysis module supports is assigned to the work queue. Any instance of the analysis module can pick up the work from the queue. When an analysis module requests work, it also submits its current version data so that it can be checked against the registered analysis module.","title":"Analysis Module Tracking"},{"location":"core/analysis_module_tracking/#versions","text":"Every analysis module type has a version , which is defined by a number of properties. When an analysis module registers a new version, the new type replaces the old type. Any attempts to acquire work with the old version are denied.","title":"Versions"},{"location":"core/analysis_module_type/","text":"Analysis Module Type \u00b6 An analysis module type represents a type of analysis module that can be registered and used to analyze observables . The specification of the type determines: what observables it is interested in analyzing what other analysis modules it depends on how long to cache analysis results what version is accepted ACE supports any number of instances of a given analysis module type running concurrently.","title":"Analysis Module Type"},{"location":"core/analysis_module_type/#analysis-module-type","text":"An analysis module type represents a type of analysis module that can be registered and used to analyze observables . The specification of the type determines: what observables it is interested in analyzing what other analysis modules it depends on how long to cache analysis results what version is accepted ACE supports any number of instances of a given analysis module type running concurrently.","title":"Analysis Module Type"},{"location":"core/analysis_request_tracking/","text":"Analysis Request Tracking \u00b6 All requests to perform analysis are made through analysis request objects and tracked in the ace.system.analysis_request.AnalysisRequestTrackingInterface","title":"Analysis Request Tracking"},{"location":"core/analysis_request_tracking/#analysis-request-tracking","text":"All requests to perform analysis are made through analysis request objects and tracked in the ace.system.analysis_request.AnalysisRequestTrackingInterface","title":"Analysis Request Tracking"},{"location":"core/analysis_requests/","text":"Analysis Requests \u00b6 There are three types of analysis requests. Root Analysis Requests \u00b6 A root analysis request is one that contains only a root analysis object. If the root analysis object does not exist, it is added to the system and tracked . If the root analysis already exists, it is replaced by a copy of a new one that merges the new analysis into the old one. Observable Analysis Request \u00b6 An observable analysis request is one that contains both a root analysis object and an observable object, as well as a copy of the analysis module type that is supposed to analyze it. These requests are added to the work queues of their respective analysis module types. References to observable analysis requests are also tracked inside the observables themselves. Observable Analysis Result \u00b6 Analysis modules record analysis results inside of the requests they receive. In other words, the analysis results are appended to the original request. These observable analysis results are then resubmitted back to the core system for processing. The observable analysis result is an analysis request when it's resubmitted back to the core system for processing.","title":"Analysis Requests"},{"location":"core/analysis_requests/#analysis-requests","text":"There are three types of analysis requests.","title":"Analysis Requests"},{"location":"core/analysis_requests/#root-analysis-requests","text":"A root analysis request is one that contains only a root analysis object. If the root analysis object does not exist, it is added to the system and tracked . If the root analysis already exists, it is replaced by a copy of a new one that merges the new analysis into the old one.","title":"Root Analysis Requests"},{"location":"core/analysis_requests/#observable-analysis-request","text":"An observable analysis request is one that contains both a root analysis object and an observable object, as well as a copy of the analysis module type that is supposed to analyze it. These requests are added to the work queues of their respective analysis module types. References to observable analysis requests are also tracked inside the observables themselves.","title":"Observable Analysis Request"},{"location":"core/analysis_requests/#observable-analysis-result","text":"Analysis modules record analysis results inside of the requests they receive. In other words, the analysis results are appended to the original request. These observable analysis results are then resubmitted back to the core system for processing. The observable analysis result is an analysis request when it's resubmitted back to the core system for processing.","title":"Observable Analysis Result"},{"location":"core/analysis_tracking/","text":"Analysis Tracking \u00b6 Analysis data is tracked using the ace.system.analysis_tracking.AnalysisTrackingInterface . The interface tracks root analysis separately from the details of the analysis.","title":"Analysis Tracking"},{"location":"core/analysis_tracking/#analysis-tracking","text":"Analysis data is tracked using the ace.system.analysis_tracking.AnalysisTrackingInterface . The interface tracks root analysis separately from the details of the analysis.","title":"Analysis Tracking"},{"location":"core/caching/","text":"Caching \u00b6 The results of analysis work are returned as analysis requests . If the analysis module type supports caching then these analysis results are tracked by ace.system.caching.CacheInterface . The analysis result contains a copy of the root analysis and the observable as they existed before the analysis, as well as the modified version as they existed after the analysis. When an analysis is requested for an observable that has a cached result, the difference between the before and after copies of the root and observables are applied. Caching uses a cache key to index the cached analysis results. The key is generated from a combination of: the type of the observable the value of the observable the time of the observable (if available) the name of the analysis module type the version of the analysis module type optionally, any additional cache keys specified by the analysis module type If the cache key changes then the lookup changes. Cache results can be set to expire after a period of time as specified by the analysis module type.","title":"Caching"},{"location":"core/caching/#caching","text":"The results of analysis work are returned as analysis requests . If the analysis module type supports caching then these analysis results are tracked by ace.system.caching.CacheInterface . The analysis result contains a copy of the root analysis and the observable as they existed before the analysis, as well as the modified version as they existed after the analysis. When an analysis is requested for an observable that has a cached result, the difference between the before and after copies of the root and observables are applied. Caching uses a cache key to index the cached analysis results. The key is generated from a combination of: the type of the observable the value of the observable the time of the observable (if available) the name of the analysis module type the version of the analysis module type optionally, any additional cache keys specified by the analysis module type If the cache key changes then the lookup changes. Cache results can be set to expire after a period of time as specified by the analysis module type.","title":"Caching"},{"location":"core/events/","text":"Events \u00b6 Every significant event that the core does can be subscribed to. Subscribers receive notifications when events are fired. Events are triggered by specific conditions. Available Events \u00b6 Event Args Description Root Analysis Events /core/analysis/root/new root:RootAnalysis A new root added. /core/analysis/root/modified root:RootAnalysis Root analysis updated. /core/analysis/root/deleted root_uuid:str Root analysis deleted. Analysis Detail Events /core/analysis/details/new root:RootAnalysis uuid:str Analysis detail added. /core/analysis/details/modified root:RootAnalysis uuid:str Analysis detail updated. /core/analysis/details/deleted uuid:str Analysis detail deleted. Alert Events /core/alert root:RootAnalysis Root sent to alert management system. Analysis Module Tracking Events /core/module/new amt:AnalysisModuleType New analysis module type added. /core/module/modified amt:AnalysisModuleType Existing analysis module type version updated. /core/module/deleted amt:AnalysisModuleType Analysis module type removed. Analysis Request Tracking Events /core/request/new request:AnalysisRequest New request tracked. /core/request/deleted request_uuid:str Request deleted. /core/request/expired request:AnalysisRequest Request expired. Cache Tracking Events /core/cache/new cache_key:str request:AnalysisRequest Analysis request result cached. Config Events /core/config/set key:str value:Any Configuration value set. Storage Events /core/storage/new sha256:str meta:ContentMetadata Content stored. /core/storage/deleted sha256:str Content deleted. Work Queue Events /core/work/queue/new amt:str New work queue created. /core/work/queue/deleted amt:str Work queue deleted. /core/work/add amt:str request:AnalysisRequest Work assigned to queue. /core/work/remove amt:str request:AnalysisRequest Removed work previously assigned to queue. Processing Events /core/analysis/root/expired root:RootAnalysis Root expired after processing. /core/cache/hit root:RootAnalysis observable:Observable ar:AnalysisRequest Cache results used for analysis. /core/work/assigned ar:AnalysisRequest Analysis request assigned to module instance. /core/processing/request/observable ar:AnalysisRequest Analysis request created for observable and analysis module type. /core/processing/request/root ar:AnalysisRequest Received request to analyze root. /core/processing/request/result ar:AnalysisRequest Received request to process analysis result.","title":"Events"},{"location":"core/events/#events","text":"Every significant event that the core does can be subscribed to. Subscribers receive notifications when events are fired. Events are triggered by specific conditions.","title":"Events"},{"location":"core/events/#available-events","text":"Event Args Description Root Analysis Events /core/analysis/root/new root:RootAnalysis A new root added. /core/analysis/root/modified root:RootAnalysis Root analysis updated. /core/analysis/root/deleted root_uuid:str Root analysis deleted. Analysis Detail Events /core/analysis/details/new root:RootAnalysis uuid:str Analysis detail added. /core/analysis/details/modified root:RootAnalysis uuid:str Analysis detail updated. /core/analysis/details/deleted uuid:str Analysis detail deleted. Alert Events /core/alert root:RootAnalysis Root sent to alert management system. Analysis Module Tracking Events /core/module/new amt:AnalysisModuleType New analysis module type added. /core/module/modified amt:AnalysisModuleType Existing analysis module type version updated. /core/module/deleted amt:AnalysisModuleType Analysis module type removed. Analysis Request Tracking Events /core/request/new request:AnalysisRequest New request tracked. /core/request/deleted request_uuid:str Request deleted. /core/request/expired request:AnalysisRequest Request expired. Cache Tracking Events /core/cache/new cache_key:str request:AnalysisRequest Analysis request result cached. Config Events /core/config/set key:str value:Any Configuration value set. Storage Events /core/storage/new sha256:str meta:ContentMetadata Content stored. /core/storage/deleted sha256:str Content deleted. Work Queue Events /core/work/queue/new amt:str New work queue created. /core/work/queue/deleted amt:str Work queue deleted. /core/work/add amt:str request:AnalysisRequest Work assigned to queue. /core/work/remove amt:str request:AnalysisRequest Removed work previously assigned to queue. Processing Events /core/analysis/root/expired root:RootAnalysis Root expired after processing. /core/cache/hit root:RootAnalysis observable:Observable ar:AnalysisRequest Cache results used for analysis. /core/work/assigned ar:AnalysisRequest Analysis request assigned to module instance. /core/processing/request/observable ar:AnalysisRequest Analysis request created for observable and analysis module type. /core/processing/request/root ar:AnalysisRequest Received request to analyze root. /core/processing/request/result ar:AnalysisRequest Received request to process analysis result.","title":"Available Events"},{"location":"core/locking/","text":"Locking \u00b6 ACE is a distributed system that requires synchronization between processes. This is accomplished by using the ace.system.locking.LockingInterface . Locks \u00b6 A lock is defined as an arbitrary string value. Typically, the value of a lock represents the name of something being locked. Once a lock is held, no other attempt to acquire the lock will succeed until it is released or the lock acquisition expires. Lock Ownership \u00b6 Every lock is made by and assigned to a lock owner . An owner is defined as an arbitrary string value. Typically, an owner value is made up of some combination of properties such as host name, process, and thread ids. This allows for identifying unique threads of execution. Deadlocks \u00b6 A lock owner can acquire multiple locks. If a lock owner attempts to acquire a lock that is already acquired by another owner, and that owner is waiting for the other to release a different lock, then a deadlock occurs. When a deadlock occurs, the request must be made again later.","title":"Locking"},{"location":"core/locking/#locking","text":"ACE is a distributed system that requires synchronization between processes. This is accomplished by using the ace.system.locking.LockingInterface .","title":"Locking"},{"location":"core/locking/#locks","text":"A lock is defined as an arbitrary string value. Typically, the value of a lock represents the name of something being locked. Once a lock is held, no other attempt to acquire the lock will succeed until it is released or the lock acquisition expires.","title":"Locks"},{"location":"core/locking/#lock-ownership","text":"Every lock is made by and assigned to a lock owner . An owner is defined as an arbitrary string value. Typically, an owner value is made up of some combination of properties such as host name, process, and thread ids. This allows for identifying unique threads of execution.","title":"Lock Ownership"},{"location":"core/locking/#deadlocks","text":"A lock owner can acquire multiple locks. If a lock owner attempts to acquire a lock that is already acquired by another owner, and that owner is waiting for the other to release a different lock, then a deadlock occurs. When a deadlock occurs, the request must be made again later.","title":"Deadlocks"},{"location":"core/modules/","text":"Analysis Modules \u00b6 An analysis module analyzes an observable to generate analysis . A module is an instance of an analysis module type .","title":"Analysis Modules"},{"location":"core/modules/#analysis-modules","text":"An analysis module analyzes an observable to generate analysis . A module is an instance of an analysis module type .","title":"Analysis Modules"},{"location":"core/storage/","text":"Storage \u00b6 The ace.system.storage.StorageInterface provides a way to store data such as files in an abstract way.","title":"Storage"},{"location":"core/storage/#storage","text":"The ace.system.storage.StorageInterface provides a way to store data such as files in an abstract way.","title":"Storage"},{"location":"core/work_queue/","text":"Work Queues \u00b6 A work queue is a queue created for each analysis module type registered with the system. These queues are filled with analysis requests that are generated when other analysis requests are processed by the system. Each analysis module type gets exactly one work queue associated to it. Work is pulled from this work queue in a manner such that each item pulled can only be pulled once.","title":"Work Queues"},{"location":"core/work_queue/#work-queues","text":"A work queue is a queue created for each analysis module type registered with the system. These queues are filled with analysis requests that are generated when other analysis requests are processed by the system. Each analysis module type gets exactly one work queue associated to it. Work is pulled from this work queue in a manner such that each item pulled can only be pulled once.","title":"Work Queues"},{"location":"design/alerts/","text":"Alerts \u00b6 When the ACE core system processes a root analysis that contains one or more detection points , it passes the root object to the alerting interface which then submits the alert to a place where analysts can manually review and disposition them.","title":"Alerts"},{"location":"design/alerts/#alerts","text":"When the ACE core system processes a root analysis that contains one or more detection points , it passes the root object to the alerting interface which then submits the alert to a place where analysts can manually review and disposition them.","title":"Alerts"},{"location":"design/analysis/","text":"Analysis \u00b6 An analysis is the output of the analysis of an observable . It consists of: zero or more observables a free form JSON formatted analysis output zero or more tags zero or more detection points The relationship between analysis and observable is always parent-child. Analysis Details \u00b6 The details of the analysis is simply free-form JSON-compatible data. This can be any value. The interpretation of this value is up to the python classes that implement the analysis modules and analysis objects. These details are stored separately from the JSON of the main root analysis object. They are loaded as needed. A brief summary of the details are stored instead.","title":"Analysis"},{"location":"design/analysis/#analysis","text":"An analysis is the output of the analysis of an observable . It consists of: zero or more observables a free form JSON formatted analysis output zero or more tags zero or more detection points The relationship between analysis and observable is always parent-child.","title":"Analysis"},{"location":"design/analysis/#analysis-details","text":"The details of the analysis is simply free-form JSON-compatible data. This can be any value. The interpretation of this value is up to the python classes that implement the analysis modules and analysis objects. These details are stored separately from the JSON of the main root analysis object. They are loaded as needed. A brief summary of the details are stored instead.","title":"Analysis Details"},{"location":"design/analysis_modes/","text":"Analysis Modes \u00b6 Analysis modes provide a way to logically group together different analysis modules and have them execute as a group. The analysis mode is a property of a root analysis object that determines what set of analysis modules (might) execute on observables in the object. Analysis modes are created by having analysis module types specify them in their list of constraints and requirements. Any analysis module can change the analysis mode of a root analysis object, which will in turn change what analysis modules continue to be executed against it.","title":"Analysis Modes"},{"location":"design/analysis_modes/#analysis-modes","text":"Analysis modes provide a way to logically group together different analysis modules and have them execute as a group. The analysis mode is a property of a root analysis object that determines what set of analysis modules (might) execute on observables in the object. Analysis modes are created by having analysis module types specify them in their list of constraints and requirements. Any analysis module can change the analysis mode of a root analysis object, which will in turn change what analysis modules continue to be executed against it.","title":"Analysis Modes"},{"location":"design/analysis_module/","text":"Analysis Module \u00b6 An analysis module is what takes an observable and generates analysis as output. Analysis modules execute in parallel to the core system. The modules that are part of the base installation are documented here .","title":"Analysis Module"},{"location":"design/analysis_module/#analysis-module","text":"An analysis module is what takes an observable and generates analysis as output. Analysis modules execute in parallel to the core system. The modules that are part of the base installation are documented here .","title":"Analysis Module"},{"location":"design/detection_points/","text":"Detection Points \u00b6 A detection point represents something determined to be suspicious enough to warrant investigation. Only observables and analysis objects can have detection points, and in practice, observables are usually the best place to put them. A entire analysis that has one or more detection points is considered by ACE to be an alert and thus has the analysis mode changed to correlation during analysis.","title":"Detection Points"},{"location":"design/detection_points/#detection-points","text":"A detection point represents something determined to be suspicious enough to warrant investigation. Only observables and analysis objects can have detection points, and in practice, observables are usually the best place to put them. A entire analysis that has one or more detection points is considered by ACE to be an alert and thus has the analysis mode changed to correlation during analysis.","title":"Detection Points"},{"location":"design/directives/","text":"Directives \u00b6 A directive is an additional analysis instruction given to an observable . Directives are typically used by analysis modules to control how they are treated by the analysis module. An observable can have zero or more directives.","title":"Directives"},{"location":"design/directives/#directives","text":"A directive is an additional analysis instruction given to an observable . Directives are typically used by analysis modules to control how they are treated by the analysis module. An observable can have zero or more directives.","title":"Directives"},{"location":"design/example_flow/","text":"Example Flow \u00b6 Let's follow a simple example to show how an alert gets created by ACE. In this example, we register analysis modules specifically to look for malicious word documents. Then we assume a sensor submits a word document for analysis. Register Analysis Modules \u00b6 Analysis modules process observables to see if an alert should be created. In this example we register two analysis modules: File Type analysis module This module accepts \" file \" observable types and outputs the type of file. For example: PDF, Word Document, Email, etc. This module adds tags like word_doc , pdf , email , etc. depending on the file type analysis result. Word Document analysis module This module accepts \" file \" observables and outputs if the word document is malicious. Additionally, it depends on the File Type module to determine if a file is malicious or not. This module may also add more observables like URLs from within the document, screenshots of the document content, etc. Analysis Module Queues and Mapping \u00b6 ACE receives the registration requests from the analysis modules and creates a queue dedicated to each. Analysis Submission \u00b6 A sensor submits a root analysis which contains an observable with type \" file .\" ACE keeps track of the root analysis and adds analysis module results throughout the lifetime of the root analysis. ACE then creates observable analysis requests for each observable within the root analysis and places them in the appropriate queue(s) for analysis modules that accept \" file \" observable types. In this case, we only have one observable. Handling Analysis Module Results \u00b6 The File Type analysis module receives the analysis request through its queue and then posts analysis results back to ACE. These results may include things like tags , directives , detection points , more observables, etc. ACE adds the analysis result to the root analysis, and then places any additional observables discovered by the analysis module into the appropriate queue(s) for further analysis. An Alert Is Born \u00b6 The Word Document analysis module found a Visual Basic macro that contained a function known to make network calls. This is suspicious and worth being presented to a security analyst. The Word Document analysis module adds a detection point to note that it has detected something that should be manually reviewed by an analyst. Once the analysis is submitted back to ACE, ACE adds the analysis to the root analysis object. ACE sees there is a detection point and will submit the root analysis as an alert.","title":"Example Flow"},{"location":"design/example_flow/#example-flow","text":"Let's follow a simple example to show how an alert gets created by ACE. In this example, we register analysis modules specifically to look for malicious word documents. Then we assume a sensor submits a word document for analysis.","title":"Example Flow"},{"location":"design/example_flow/#register-analysis-modules","text":"Analysis modules process observables to see if an alert should be created. In this example we register two analysis modules: File Type analysis module This module accepts \" file \" observable types and outputs the type of file. For example: PDF, Word Document, Email, etc. This module adds tags like word_doc , pdf , email , etc. depending on the file type analysis result. Word Document analysis module This module accepts \" file \" observables and outputs if the word document is malicious. Additionally, it depends on the File Type module to determine if a file is malicious or not. This module may also add more observables like URLs from within the document, screenshots of the document content, etc.","title":"Register Analysis Modules"},{"location":"design/example_flow/#analysis-module-queues-and-mapping","text":"ACE receives the registration requests from the analysis modules and creates a queue dedicated to each.","title":"Analysis Module Queues and Mapping"},{"location":"design/example_flow/#analysis-submission","text":"A sensor submits a root analysis which contains an observable with type \" file .\" ACE keeps track of the root analysis and adds analysis module results throughout the lifetime of the root analysis. ACE then creates observable analysis requests for each observable within the root analysis and places them in the appropriate queue(s) for analysis modules that accept \" file \" observable types. In this case, we only have one observable.","title":"Analysis Submission"},{"location":"design/example_flow/#handling-analysis-module-results","text":"The File Type analysis module receives the analysis request through its queue and then posts analysis results back to ACE. These results may include things like tags , directives , detection points , more observables, etc. ACE adds the analysis result to the root analysis, and then places any additional observables discovered by the analysis module into the appropriate queue(s) for further analysis.","title":"Handling Analysis Module Results"},{"location":"design/example_flow/#an-alert-is-born","text":"The Word Document analysis module found a Visual Basic macro that contained a function known to make network calls. This is suspicious and worth being presented to a security analyst. The Word Document analysis module adds a detection point to note that it has detected something that should be manually reviewed by an analyst. Once the analysis is submitted back to ACE, ACE adds the analysis to the root analysis object. ACE sees there is a detection point and will submit the root analysis as an alert.","title":"An Alert Is Born"},{"location":"design/observable/","text":"Observables \u00b6 An observable represents an observation made during the course of analysis. It always has a type and a value , and, optionally, has a time at which the observation was made. If the observable is missing the time, then the time is assumed to be the time of the entire event that is being analyzed. Observables are always children of analysis -based objects. Observables are analyzed by analysis modules which generate analysis as output. The newly created analysis can also contain more observables. Observables are unique according to their type, value, and time. If an observable with the same type, value, and time as another existing observable is added, it references the existing observable instead of creating a new one. Note that observables are unique by time. You can optionally group them together by time if you need to. Tagging \u00b6 An observable can have zero or more tags . Tagging is used to tie some concept, idea or grouping property to the observables. Directives \u00b6 An observable can have zero or more directives . Directives are used to give analysis modules some additional instructions on how to handle the observable. Redirection \u00b6 An observable can include a redirection , which points to another observable. Redirections are often used when extracting artifacts from files. They give ACE the ability to say \"This file actually came from this other file.\" A common example usage of this feature is determining which file to send to a sandboxing system. If a file was generated as part of an analysis, redirection can be used to point to the original file, giving the sandbox analysis module the correct file to analyze. Linking \u00b6 Linking occurs when an observable can be linked to another observable. Any tags applied to the original observable are also applied to the linked observable. Limited Analysis \u00b6 Given an observable, a limited analysis results from limiting what analysis modules are allowed to execute against it. This occurs by specifying one or more analysis modules as the limited analysis for an observable. Only modules in the specified list will be executed against such observable, and only if the module accepts the observable. Excluded Analysis \u00b6 An observable can restrict what analysis modules are executed against it by specifying one or more analysis modules as excluded analysis . Modules in the excluded analysis list are excluded from analyzing the observable. These modules will not execute against the observable regardless of any other condition. Relationships \u00b6 An observable can have a relationship to another observable. This has meaning only to analysis modules that utilized these relationships. Grouping by Time \u00b6 Observables can be grouped together for analysis purposes by time. This allows multiple observations over some time period to be treated as a single observation. For example, if the same IP address was observed 50 times over 5 seconds, they can be grouped into a single observation over that 5 second time period. Analysis \u00b6 An observable can have zero or more analysis objects attached to it. These represent the analysis performed by analysis modules .","title":"Observables"},{"location":"design/observable/#observables","text":"An observable represents an observation made during the course of analysis. It always has a type and a value , and, optionally, has a time at which the observation was made. If the observable is missing the time, then the time is assumed to be the time of the entire event that is being analyzed. Observables are always children of analysis -based objects. Observables are analyzed by analysis modules which generate analysis as output. The newly created analysis can also contain more observables. Observables are unique according to their type, value, and time. If an observable with the same type, value, and time as another existing observable is added, it references the existing observable instead of creating a new one. Note that observables are unique by time. You can optionally group them together by time if you need to.","title":"Observables"},{"location":"design/observable/#tagging","text":"An observable can have zero or more tags . Tagging is used to tie some concept, idea or grouping property to the observables.","title":"Tagging"},{"location":"design/observable/#directives","text":"An observable can have zero or more directives . Directives are used to give analysis modules some additional instructions on how to handle the observable.","title":"Directives"},{"location":"design/observable/#redirection","text":"An observable can include a redirection , which points to another observable. Redirections are often used when extracting artifacts from files. They give ACE the ability to say \"This file actually came from this other file.\" A common example usage of this feature is determining which file to send to a sandboxing system. If a file was generated as part of an analysis, redirection can be used to point to the original file, giving the sandbox analysis module the correct file to analyze.","title":"Redirection"},{"location":"design/observable/#linking","text":"Linking occurs when an observable can be linked to another observable. Any tags applied to the original observable are also applied to the linked observable.","title":"Linking"},{"location":"design/observable/#limited-analysis","text":"Given an observable, a limited analysis results from limiting what analysis modules are allowed to execute against it. This occurs by specifying one or more analysis modules as the limited analysis for an observable. Only modules in the specified list will be executed against such observable, and only if the module accepts the observable.","title":"Limited Analysis"},{"location":"design/observable/#excluded-analysis","text":"An observable can restrict what analysis modules are executed against it by specifying one or more analysis modules as excluded analysis . Modules in the excluded analysis list are excluded from analyzing the observable. These modules will not execute against the observable regardless of any other condition.","title":"Excluded Analysis"},{"location":"design/observable/#relationships","text":"An observable can have a relationship to another observable. This has meaning only to analysis modules that utilized these relationships.","title":"Relationships"},{"location":"design/observable/#grouping-by-time","text":"Observables can be grouped together for analysis purposes by time. This allows multiple observations over some time period to be treated as a single observation. For example, if the same IP address was observed 50 times over 5 seconds, they can be grouped into a single observation over that 5 second time period.","title":"Grouping by Time"},{"location":"design/observable/#analysis","text":"An observable can have zero or more analysis objects attached to it. These represent the analysis performed by analysis modules .","title":"Analysis"},{"location":"design/root_analysis/","text":"Root Analysis \u00b6 The analysis --> observable --> analysis relationship forms a hierarchical tree with a special analysis object called the root analysis as the starting point of the tree. A root analysis is a special type of analysis object that contains additional information about the analysis as a whole, such as, what generated it, description information, instructions for analysts, etc... A root analysis can become an alert if one or more detection points are added during the course of analysis.","title":"Root Analysis"},{"location":"design/root_analysis/#root-analysis","text":"The analysis --> observable --> analysis relationship forms a hierarchical tree with a special analysis object called the root analysis as the starting point of the tree. A root analysis is a special type of analysis object that contains additional information about the analysis as a whole, such as, what generated it, description information, instructions for analysts, etc... A root analysis can become an alert if one or more detection points are added during the course of analysis.","title":"Root Analysis"},{"location":"design/tags/","text":"Tags \u00b6 Tagging is a way to add additional information or context to analysis data. Tags can also be used to add relationships between different root analysis objects. Only observables and analysis can be tagged. In practice, observables are usually what get tagged. Tagging shows up in the GUI as labels of varying colors. The value of a tag is any UTF8 encoded string.","title":"Tags"},{"location":"design/tags/#tags","text":"Tagging is a way to add additional information or context to analysis data. Tags can also be used to add relationships between different root analysis objects. Only observables and analysis can be tagged. In practice, observables are usually what get tagged. Tagging shows up in the GUI as labels of varying colors. The value of a tag is any UTF8 encoded string.","title":"Tags"},{"location":"development/","text":"ACE2 Development Guide \u00b6 Quick Start - Root Analysis \u00b6 All analysis starts with a root object. The root contains the details of the analysis in a schema-less JSON format. The process making the submission identifies the initial observations . Any kind of process in any programming language can be used to feed root objects to ACE using the API . from ace.analysis import RootAnalysis root = RootAnalysis(details={\"source_ip\": \"1.2.3.4\"}) observable = root.add_observable(\"ipv4\", \"1.2.3.4\") root.submit() Quick Start - Analysis Modules \u00b6 All analysis is performed by analysis modules . Modules execute as a separate component of the system. ACE has a built-in module manager that can be used to build analysis modules in Python. You are free to author analysis modules in any programming language using the API . class IPv4Lookup(AnalysisModule): type = AnalysisModuleType( name =\"ipv4_lookup\", description = \"Looks up IPv4 addresses in some useful way.\") def execute_analysis(self, root, observable, result): result.details = self.execute_cool_analysis(observable) manger = AnalysisModuleManager() manager.add_module(IPv4Lookup()) manager.run() System Design Overview \u00b6 ACE is split up into three pieces: core system , analysis modules , and alert management . Each system operates on its own, independent of each other. Communication is performed through defined interfaces. Analysis Module Overview \u00b6 An analysis module takes an observable as input, generates analysis results, and may produce zero or more observables as output. ACE can support any number of analysis modules in any programming language. Core System Overview \u00b6 The core system is responsible for tracking analysis requests/results, storing file content, maintaining a result cache, and other required operations. The core system is itself composed of individual components that are simple to extend to provide additional functionality. Alert Management Overview \u00b6 The alert management system manages alerts generated by a core system. It provides basic alert management tooling, as well as a graphical user interface for analysts to review and disposition the alerts. Core System Details \u00b6 The core system is composed of multiple abstract interfaces , which can each be implemented in any manner required. These core system interfaces are listed below. alerting: provides an interface to send an alert to the alert management system analysis tracking: keeps track of root analysis data and analysis details caching: keeps a cache of recent analysis results configuration: provides a way to read and write configuration data events: provides a way to subscribe to events generated by the core system module tracking: keeps track of registered analysis modules request tracking: keeps track of analysis requests storage: provides a generic interface to read and write arbitrary binary data work queue: provides an interface for analysis modules to receive analysis requests Each interface is defined in ace.system.* Each abstract interface function is wrapped by an importable function that may provide additional functionality, error checking, or simplification for use. Core System Initialization \u00b6 The first step is to provide a running core system that implements all the interfaces listed above. Analysis Module Registration \u00b6 Once the core system is running, analysis modules must then register themselves to the system. This is accomplished by calling the register_analysis_module_type function. An analysis module type defines what requirements and restrictions are around certain kinds of observables that the analysis module will accept. The most simple and common requirement is providing a list of one or more observable types the module supports. The core system will only generate analysis requests for observables that match the given type(s). A more complex example might be an analysis module that depends on another analysis module, in which case, ACE would not submit an analysis request until the dependency is met. Analysis modules also register under specific versions. The core system keeps track of the registration data. Finally, each module asks the core system for the next analysis request to process by calling the get_next_analysis_request function, which blocks until work is available or the analysis reaches time out. Analysis Module Versioning \u00b6 Analysis modules have two version fields: version and extended_version . The version field simply contains a free-form string version of the module, such as 1.0.0 . The extended_version** contains zero or more optional version strings. These can be used to represent the version of data that is used by the module, such as detection signatures. Each call to get_next_analysis_request includes the version data of the current analysis module. If the version data does not match then the call is rejected. This gives the module as chance to update data, or exit to allow automation to update the module. Root Analysis Request Processing \u00b6 New analysis requests are submitted to the core system by submitting a root analysis request . The analysis is tracked, and new observable analysis requests are generated for each observable that requires analysis by any registered analysis module. These requests are placed into the work queues assigned to each analysis module type. The requests are then picked up by the analysis modules through these queues. Analysis Result Processing \u00b6 Analysis modules post the results of the analysis by submitting an observable analysis result , which includes both the original request, as well as the results of the analysis. The difference between the original request and the generated analysis is computed. Then the difference is applied to the tracked analysis objects. Any additional observations are analyzed as before, generating new observable analysis requests. This process continues until all analysis modules have completed analysis for all observables they accept. Alerting \u00b6 Any root analysis that has one or more detection points is submitted to the alert management system. This can occur multiple times for the same root analysis. Analysis Result Cache \u00b6 The result of the analysis of an observation can be cached if an analysis module is registered with a time-to-live value set for the cache. If the module types has this value, then it looks up results in the cache before making any analysis requests. This prevents duplicate analysis work in the cases where the results can be cached. Storage \u00b6 ACE provides a very generic way to store any binary content. Data is stored as binary and referenced by sha256 hash. All data is associated to a root analysis. Any data that is no longer referenced automatically expires after some configurable time. Work Queues \u00b6 When a new analysis module type is registered, a new work queue is created for that type. When the core system generates analysis requests for that type, those requests are sent to the work queue. The external analysis module instances then acquire these analysis requests through the work queue. A single analysis request cannot be acquired by multiple analysis module instances. The queues are FIFO. Workflow Example \u00b6 This walks you through a really simple example of pretending to analyze an observable of type \"test.\" Note that we are showing pseudo code for different components of ACE. # assume this initializes a core system initialize_system() # # assume the role of analysis module first # ---------------------------------------- # register a basic analysis module # in this case we register an analysis module of type \"test\" which accepts observables of type \"test\" amt = AnalysisModuleType(\"test\", \"this is a test analysis module\", ['test']) register_analysis_module_type(amt) # # assume the role of something that collects stuff to analyze # ----------------------------------------------------------- # create a new root analysis as our analysis \"container\" root = RootAnalysis() # add a new observable with type \"type\" and value \"test\" observable = root.add_observable(\"test\", \"test\") # submit the root for analysis to the core system process_analysis_request(root.create_analysis_request()) # at this point the core system has taken the request and generated # a new observable analysis request which is placed in the work queue for analysis module type \"test\" # # assume the role of the analysis module # -------------------------------------- # first we create an identity # this is just some unique name that identifies the *instance* of the executing analysis module owner_uuid = \"test host localhost pid 12343 tid 12343353\" # receive the next work item # the format is get_next_analysis_request(who_you_are, which_analysis_module_type, how_long_to_wait) request = get_next_analysis_request(owner_uuid, amt, 0) # pretend to analyze it by generating details analysis_details = {\"test\": \"result\"} request.result = request.create_result() request.result.observable.add_analysis(type=amt, details=analysis_details) # submit the result of the analysis to the core system process_analysis_request(request) # # at this point the analysis is complete because we did not add an additional observables #","title":"ACE2 Development Guide"},{"location":"development/#ace2-development-guide","text":"","title":"ACE2 Development Guide"},{"location":"development/#quick-start-root-analysis","text":"All analysis starts with a root object. The root contains the details of the analysis in a schema-less JSON format. The process making the submission identifies the initial observations . Any kind of process in any programming language can be used to feed root objects to ACE using the API . from ace.analysis import RootAnalysis root = RootAnalysis(details={\"source_ip\": \"1.2.3.4\"}) observable = root.add_observable(\"ipv4\", \"1.2.3.4\") root.submit()","title":"Quick Start - Root Analysis"},{"location":"development/#quick-start-analysis-modules","text":"All analysis is performed by analysis modules . Modules execute as a separate component of the system. ACE has a built-in module manager that can be used to build analysis modules in Python. You are free to author analysis modules in any programming language using the API . class IPv4Lookup(AnalysisModule): type = AnalysisModuleType( name =\"ipv4_lookup\", description = \"Looks up IPv4 addresses in some useful way.\") def execute_analysis(self, root, observable, result): result.details = self.execute_cool_analysis(observable) manger = AnalysisModuleManager() manager.add_module(IPv4Lookup()) manager.run()","title":"Quick Start - Analysis Modules"},{"location":"development/#system-design-overview","text":"ACE is split up into three pieces: core system , analysis modules , and alert management . Each system operates on its own, independent of each other. Communication is performed through defined interfaces.","title":"System Design Overview"},{"location":"development/#analysis-module-overview","text":"An analysis module takes an observable as input, generates analysis results, and may produce zero or more observables as output. ACE can support any number of analysis modules in any programming language.","title":"Analysis Module Overview"},{"location":"development/#core-system-overview","text":"The core system is responsible for tracking analysis requests/results, storing file content, maintaining a result cache, and other required operations. The core system is itself composed of individual components that are simple to extend to provide additional functionality.","title":"Core System Overview"},{"location":"development/#alert-management-overview","text":"The alert management system manages alerts generated by a core system. It provides basic alert management tooling, as well as a graphical user interface for analysts to review and disposition the alerts.","title":"Alert Management Overview"},{"location":"development/#core-system-details","text":"The core system is composed of multiple abstract interfaces , which can each be implemented in any manner required. These core system interfaces are listed below. alerting: provides an interface to send an alert to the alert management system analysis tracking: keeps track of root analysis data and analysis details caching: keeps a cache of recent analysis results configuration: provides a way to read and write configuration data events: provides a way to subscribe to events generated by the core system module tracking: keeps track of registered analysis modules request tracking: keeps track of analysis requests storage: provides a generic interface to read and write arbitrary binary data work queue: provides an interface for analysis modules to receive analysis requests Each interface is defined in ace.system.* Each abstract interface function is wrapped by an importable function that may provide additional functionality, error checking, or simplification for use.","title":"Core System Details"},{"location":"development/#core-system-initialization","text":"The first step is to provide a running core system that implements all the interfaces listed above.","title":"Core System Initialization"},{"location":"development/#analysis-module-registration","text":"Once the core system is running, analysis modules must then register themselves to the system. This is accomplished by calling the register_analysis_module_type function. An analysis module type defines what requirements and restrictions are around certain kinds of observables that the analysis module will accept. The most simple and common requirement is providing a list of one or more observable types the module supports. The core system will only generate analysis requests for observables that match the given type(s). A more complex example might be an analysis module that depends on another analysis module, in which case, ACE would not submit an analysis request until the dependency is met. Analysis modules also register under specific versions. The core system keeps track of the registration data. Finally, each module asks the core system for the next analysis request to process by calling the get_next_analysis_request function, which blocks until work is available or the analysis reaches time out.","title":"Analysis Module Registration"},{"location":"development/#analysis-module-versioning","text":"Analysis modules have two version fields: version and extended_version . The version field simply contains a free-form string version of the module, such as 1.0.0 . The extended_version** contains zero or more optional version strings. These can be used to represent the version of data that is used by the module, such as detection signatures. Each call to get_next_analysis_request includes the version data of the current analysis module. If the version data does not match then the call is rejected. This gives the module as chance to update data, or exit to allow automation to update the module.","title":"Analysis Module Versioning"},{"location":"development/#root-analysis-request-processing","text":"New analysis requests are submitted to the core system by submitting a root analysis request . The analysis is tracked, and new observable analysis requests are generated for each observable that requires analysis by any registered analysis module. These requests are placed into the work queues assigned to each analysis module type. The requests are then picked up by the analysis modules through these queues.","title":"Root Analysis Request Processing"},{"location":"development/#analysis-result-processing","text":"Analysis modules post the results of the analysis by submitting an observable analysis result , which includes both the original request, as well as the results of the analysis. The difference between the original request and the generated analysis is computed. Then the difference is applied to the tracked analysis objects. Any additional observations are analyzed as before, generating new observable analysis requests. This process continues until all analysis modules have completed analysis for all observables they accept.","title":"Analysis Result Processing"},{"location":"development/#alerting","text":"Any root analysis that has one or more detection points is submitted to the alert management system. This can occur multiple times for the same root analysis.","title":"Alerting"},{"location":"development/#analysis-result-cache","text":"The result of the analysis of an observation can be cached if an analysis module is registered with a time-to-live value set for the cache. If the module types has this value, then it looks up results in the cache before making any analysis requests. This prevents duplicate analysis work in the cases where the results can be cached.","title":"Analysis Result Cache"},{"location":"development/#storage","text":"ACE provides a very generic way to store any binary content. Data is stored as binary and referenced by sha256 hash. All data is associated to a root analysis. Any data that is no longer referenced automatically expires after some configurable time.","title":"Storage"},{"location":"development/#work-queues","text":"When a new analysis module type is registered, a new work queue is created for that type. When the core system generates analysis requests for that type, those requests are sent to the work queue. The external analysis module instances then acquire these analysis requests through the work queue. A single analysis request cannot be acquired by multiple analysis module instances. The queues are FIFO.","title":"Work Queues"},{"location":"development/#workflow-example","text":"This walks you through a really simple example of pretending to analyze an observable of type \"test.\" Note that we are showing pseudo code for different components of ACE. # assume this initializes a core system initialize_system() # # assume the role of analysis module first # ---------------------------------------- # register a basic analysis module # in this case we register an analysis module of type \"test\" which accepts observables of type \"test\" amt = AnalysisModuleType(\"test\", \"this is a test analysis module\", ['test']) register_analysis_module_type(amt) # # assume the role of something that collects stuff to analyze # ----------------------------------------------------------- # create a new root analysis as our analysis \"container\" root = RootAnalysis() # add a new observable with type \"type\" and value \"test\" observable = root.add_observable(\"test\", \"test\") # submit the root for analysis to the core system process_analysis_request(root.create_analysis_request()) # at this point the core system has taken the request and generated # a new observable analysis request which is placed in the work queue for analysis module type \"test\" # # assume the role of the analysis module # -------------------------------------- # first we create an identity # this is just some unique name that identifies the *instance* of the executing analysis module owner_uuid = \"test host localhost pid 12343 tid 12343353\" # receive the next work item # the format is get_next_analysis_request(who_you_are, which_analysis_module_type, how_long_to_wait) request = get_next_analysis_request(owner_uuid, amt, 0) # pretend to analyze it by generating details analysis_details = {\"test\": \"result\"} request.result = request.create_result() request.result.observable.add_analysis(type=amt, details=analysis_details) # submit the result of the analysis to the core system process_analysis_request(request) # # at this point the analysis is complete because we did not add an additional observables #","title":"Workflow Example"},{"location":"development/caching/","text":"","title":"Caching"},{"location":"development/modules/","text":"Analysis Module Development \u00b6 Analysis modules can be implemented in Python or any other programming language .","title":"Analysis Module Development"},{"location":"development/modules/#analysis-module-development","text":"Analysis modules can be implemented in Python or any other programming language .","title":"Analysis Module Development"},{"location":"development/modules/module_guide/","text":"Analysis Module Development Guide (Python) \u00b6 The ACE core library provides base classes and utilities for developing analysis modules. They are provided as a means to accelerate development. You do not need to use them (see this guide instead. ) TL;DR \u00b6 Step 1: Define the Module Type \u00b6 from ace.analysis import AnalysisModuleType amt = AnalysisModuleType( name=\"example_analysis\", description=\"Example analysis module type.\" ) Step 2: Define the Analysis Module \u00b6 from ace.module.base import AnalysisModule class ExampleAnalysisModule(AnalysisModule): type = amt def execute_analysis(self, root, observable, analysis): analysis.details = {\"Hello\": \"World\"} observable = analysis.add_observable(\"ipv4\", \"1.2.3.4\") observable.add_detection_point(\"lol evil ip\") Step 3: Register the Module Type \u00b6 from ace.api import get_api get_api().register_analysis_module_type(amt) Step 4: Run an Analysis Module Manager \u00b6 from ace.module.manager import AnalysisModuleManager manager = AnalysisModuleManager() manager.add_module(ExampleAnalysisModule()) manager.run() Analysis Module Type \u00b6 An analysis module type describes all the properties of the analysis module such as what observables it wants to analyze what additional information is required before the module will consider analyzing it In the core library the type is represented by the ace.analysis.AnalysisModuleType class. Analysis Module \u00b6 The module that implements the analysis logic is represented by the ace.module.AnalysisModule class. Every instance of AnalysisModule has an associated AnalysisModuleType . Note that the type is separate from the implementation. A simple example of an analysis module that does nothing is as follows. class ExampleAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"example_analysis_module\", description=\"Example analysis module that does nothing.\") def execute_analysis(self, root, observable, analysis): pass Loading Additional Resources \u00b6 Override and use the load function to load additional resources such as signatures and resource files. class ExampleAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"example_analysis_module\", description=\"Example analysis module that does nothing.\") def execute_analysis(self, root, observable, analysis): pass def load(self): # load signature files # open files # open network connections Upgrading \u00b6 Override the upgrade function to re-load any data needed to compute the analysis. This is useful for analysis modules that use external data such as signatures and rule sets. class ExampleAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"example_analysis_module\", description=\"Example analysis module that does nothing.\") def execute_analysis(self, root, observable, analysis): pass def upgrade(self): # (for example) self.rules = self.load_my_rule_set() Async vs Sync \u00b6 The ACE core library supports analysis modules written to taken advantage of the asyncio library. If you prepend async to execute_analysis , upgrade and load then the module will be considered async . Otherwise the module is considered sync . Modules that are sync are executed on their own process. Modules that are async are executed as part of the asyncio event loop. # define an analysis module that uses asyncio class ExampleAsyncAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"async_module\", description=\"Example async analysis module.\" ) async def execute_analysis(self, root, observable, analysis): # do async analysis async def upgrade(self): # do async upgrade async def load(self): # do async load You can also use the AsyncAnalysisModule class which already has the function definitions set up correctly (meaning you don't have to override upgrade and load if you're not using them.) Analysis \u00b6 You are expected to analyze the observable passed into the execute_analysis function, and store the results in the analysis object. The details of the analysis are stored in the details property of the analysis object. This value must be a dict that can be translated into JSON using Python's standard json library. def execute_analysis(self, root, observable, analysis): # details have no schema analysis.details = { \"results\": \"my results here\" } You can also add an additional observables you find. def execute_analysis(self, root, observable, analysis): # details have no schema analysis.details = { \"results\": \"my results here\" } # add an ip address as an observable analysis.add_observable(\"ipv4\", \"1.2.3.4\") You can do a lot of other things with observables.","title":"Analysis Module Development Guide (Python)"},{"location":"development/modules/module_guide/#analysis-module-development-guide-python","text":"The ACE core library provides base classes and utilities for developing analysis modules. They are provided as a means to accelerate development. You do not need to use them (see this guide instead. )","title":"Analysis Module Development Guide (Python)"},{"location":"development/modules/module_guide/#tldr","text":"","title":"TL;DR"},{"location":"development/modules/module_guide/#step-1-define-the-module-type","text":"from ace.analysis import AnalysisModuleType amt = AnalysisModuleType( name=\"example_analysis\", description=\"Example analysis module type.\" )","title":"Step 1: Define the Module Type"},{"location":"development/modules/module_guide/#step-2-define-the-analysis-module","text":"from ace.module.base import AnalysisModule class ExampleAnalysisModule(AnalysisModule): type = amt def execute_analysis(self, root, observable, analysis): analysis.details = {\"Hello\": \"World\"} observable = analysis.add_observable(\"ipv4\", \"1.2.3.4\") observable.add_detection_point(\"lol evil ip\")","title":"Step 2: Define the Analysis Module"},{"location":"development/modules/module_guide/#step-3-register-the-module-type","text":"from ace.api import get_api get_api().register_analysis_module_type(amt)","title":"Step 3: Register the Module Type"},{"location":"development/modules/module_guide/#step-4-run-an-analysis-module-manager","text":"from ace.module.manager import AnalysisModuleManager manager = AnalysisModuleManager() manager.add_module(ExampleAnalysisModule()) manager.run()","title":"Step 4: Run an Analysis Module Manager"},{"location":"development/modules/module_guide/#analysis-module-type","text":"An analysis module type describes all the properties of the analysis module such as what observables it wants to analyze what additional information is required before the module will consider analyzing it In the core library the type is represented by the ace.analysis.AnalysisModuleType class.","title":"Analysis Module Type"},{"location":"development/modules/module_guide/#analysis-module","text":"The module that implements the analysis logic is represented by the ace.module.AnalysisModule class. Every instance of AnalysisModule has an associated AnalysisModuleType . Note that the type is separate from the implementation. A simple example of an analysis module that does nothing is as follows. class ExampleAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"example_analysis_module\", description=\"Example analysis module that does nothing.\") def execute_analysis(self, root, observable, analysis): pass","title":"Analysis Module"},{"location":"development/modules/module_guide/#loading-additional-resources","text":"Override and use the load function to load additional resources such as signatures and resource files. class ExampleAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"example_analysis_module\", description=\"Example analysis module that does nothing.\") def execute_analysis(self, root, observable, analysis): pass def load(self): # load signature files # open files # open network connections","title":"Loading Additional Resources"},{"location":"development/modules/module_guide/#upgrading","text":"Override the upgrade function to re-load any data needed to compute the analysis. This is useful for analysis modules that use external data such as signatures and rule sets. class ExampleAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"example_analysis_module\", description=\"Example analysis module that does nothing.\") def execute_analysis(self, root, observable, analysis): pass def upgrade(self): # (for example) self.rules = self.load_my_rule_set()","title":"Upgrading"},{"location":"development/modules/module_guide/#async-vs-sync","text":"The ACE core library supports analysis modules written to taken advantage of the asyncio library. If you prepend async to execute_analysis , upgrade and load then the module will be considered async . Otherwise the module is considered sync . Modules that are sync are executed on their own process. Modules that are async are executed as part of the asyncio event loop. # define an analysis module that uses asyncio class ExampleAsyncAnalysisModule(AnalysisModule): type = AnalysisModuleType( name=\"async_module\", description=\"Example async analysis module.\" ) async def execute_analysis(self, root, observable, analysis): # do async analysis async def upgrade(self): # do async upgrade async def load(self): # do async load You can also use the AsyncAnalysisModule class which already has the function definitions set up correctly (meaning you don't have to override upgrade and load if you're not using them.)","title":"Async vs Sync"},{"location":"development/modules/module_guide/#analysis","text":"You are expected to analyze the observable passed into the execute_analysis function, and store the results in the analysis object. The details of the analysis are stored in the details property of the analysis object. This value must be a dict that can be translated into JSON using Python's standard json library. def execute_analysis(self, root, observable, analysis): # details have no schema analysis.details = { \"results\": \"my results here\" } You can also add an additional observables you find. def execute_analysis(self, root, observable, analysis): # details have no schema analysis.details = { \"results\": \"my results here\" } # add an ip address as an observable analysis.add_observable(\"ipv4\", \"1.2.3.4\") You can do a lot of other things with observables.","title":"Analysis"},{"location":"development/modules/python_modules/","text":"Analysis Modules (Python) \u00b6 Analysis modules extend the ace.module.base.AnalysisModule class. The only function that needs to be implemented is the execute_analysis function. def execute_analysis(root, observable, analysis) Execute analysis takes three parameters: root - the root analysis object. observable - the observable to be analyzed analysis - prepared analysis object to store the results of the analysis into Synchronous vs Asynchronous \u00b6 Analysis modules can be either synchronous or asyncronous . By default modules are synchronous. To define an analysis module as asynchronous, simply add the async modified to the function definition. # defines a module as async async def execute_analysis(root, observable, analysis) Async modules are executed as part of Python's asyncio event loop. Sync modules are executed on their own child process . Async modules are appropriate for the following types of I/O bound analysis: API calls external process execution generic networking fast analysis Sync modules are approproate for CPU intensive types of analysis.","title":"Analysis Modules (Python)"},{"location":"development/modules/python_modules/#analysis-modules-python","text":"Analysis modules extend the ace.module.base.AnalysisModule class. The only function that needs to be implemented is the execute_analysis function. def execute_analysis(root, observable, analysis) Execute analysis takes three parameters: root - the root analysis object. observable - the observable to be analyzed analysis - prepared analysis object to store the results of the analysis into","title":"Analysis Modules (Python)"},{"location":"development/modules/python_modules/#synchronous-vs-asynchronous","text":"Analysis modules can be either synchronous or asyncronous . By default modules are synchronous. To define an analysis module as asynchronous, simply add the async modified to the function definition. # defines a module as async async def execute_analysis(root, observable, analysis) Async modules are executed as part of Python's asyncio event loop. Sync modules are executed on their own child process . Async modules are appropriate for the following types of I/O bound analysis: API calls external process execution generic networking fast analysis Sync modules are approproate for CPU intensive types of analysis.","title":"Synchronous vs Asynchronous"},{"location":"development/system/","text":"Core System \u00b6 Subsystem Composition \u00b6 The core system is composed of subsystems that implement some required features of ACE. The full contract of the entire system is found here . The core system is composed of multiple interfaces that make up an entire system. Thus, you can create a core that is made of the subsystems that provide the functionality you need for however you need to run the core. For example, the threaded system implements a very simple in-memory threaded version of various subsystems suitable for unit testing. Core API \u00b6 The core API is the set of function calls made available by all of the subsystem interfaces. These functions are decorated with the @coreapi decorator.","title":"Core System"},{"location":"development/system/#core-system","text":"","title":"Core System"},{"location":"development/system/#subsystem-composition","text":"The core system is composed of subsystems that implement some required features of ACE. The full contract of the entire system is found here . The core system is composed of multiple interfaces that make up an entire system. Thus, you can create a core that is made of the subsystems that provide the functionality you need for however you need to run the core. For example, the threaded system implements a very simple in-memory threaded version of various subsystems suitable for unit testing.","title":"Subsystem Composition"},{"location":"development/system/#core-api","text":"The core API is the set of function calls made available by all of the subsystem interfaces. These functions are decorated with the @coreapi decorator.","title":"Core API"},{"location":"development/system/concurrency/","text":"Concurrency \u00b6 The core system is designed in such a way that each subsystem can execute independently from the other. A distributed locking system is available to serialize multiple concurrent modification requests to the same object. Concurrent Modification Restrictions \u00b6 The core system must resolve concurrent requests to satisfy analysis results. Analysis results can contain side effects . This makes result resolution challenging. Consider the following scenario: root analysis object Z 1 contains observable O 1 . Two different analysis modules A 1 and A 2 are registered to analyze O 1 . Both analysis modules operate independently. A 2 finishes first adding an analysis result R 2 to O 1 and adding a tag T 1 to O 1 . Adding the tag is a side effect . A 1 finishes second and adds analysis result R 1 to O 1 but does not add a tag. Due to the side effect, the core system cannot simply replace O 1 when it resolves R 1 because it would overwrite it without the tag that A 2 added to it. The core system instead merges the results together. Merging \u00b6 Merging allows one object to be merged into another. There are two types of merging in the core system: direct and differential . Python classes that support merging will have apply_merge and apply_diff_merge functions. Direct Merge \u00b6 A direct merge takes the form of target.apply_merge(source) and copies anything in source that is not in target . In our previous example, a direct merge of R 1 into O 1 would preserve T 1 because it would only add the analysis result R 1 and do nothing else. Likewise, if R 1 finished first, then a direct merge of R 2 O 1 would add T 1 into O 1 because T 1 does not exist in the target. There is another scenario that requires additional logic to handle. Consider the following: root analysis object Z 1 contains observable O 1 . Two different analysis modules A 1 and A 2 are registered to analyze O 1 . Both analysis modules operate independently. A 1 finishes first and adds analysis result R 1 to O 1 , but also changes the analysis_mode property of Z 1 from analysis to correlation . This change to Z 1 is a side effect . A 2 finishes second and adds analysis result R 2 to O 1 . However, it does not change the analysis_mode property of Z 1 . At this point, the core system has no idea if A 2 left the property alone or if it changed it back . Differential Merge \u00b6 A differential merge applies the changes (delta) between two objects to a target object. It takes the form of target.apply_diff_merge(before, after) where target is the object to receive the changes, before is the state of the object before the changes were made, and after is the state of the object after the changes were made. If we apply this to the previous scenario, the differential merge would see that the analysis_mode property was the same in both the before and after objects, so R 2 would not overwrite the property with the wrong value.","title":"Concurrency"},{"location":"development/system/concurrency/#concurrency","text":"The core system is designed in such a way that each subsystem can execute independently from the other. A distributed locking system is available to serialize multiple concurrent modification requests to the same object.","title":"Concurrency"},{"location":"development/system/concurrency/#concurrent-modification-restrictions","text":"The core system must resolve concurrent requests to satisfy analysis results. Analysis results can contain side effects . This makes result resolution challenging. Consider the following scenario: root analysis object Z 1 contains observable O 1 . Two different analysis modules A 1 and A 2 are registered to analyze O 1 . Both analysis modules operate independently. A 2 finishes first adding an analysis result R 2 to O 1 and adding a tag T 1 to O 1 . Adding the tag is a side effect . A 1 finishes second and adds analysis result R 1 to O 1 but does not add a tag. Due to the side effect, the core system cannot simply replace O 1 when it resolves R 1 because it would overwrite it without the tag that A 2 added to it. The core system instead merges the results together.","title":"Concurrent Modification Restrictions"},{"location":"development/system/concurrency/#merging","text":"Merging allows one object to be merged into another. There are two types of merging in the core system: direct and differential . Python classes that support merging will have apply_merge and apply_diff_merge functions.","title":"Merging"},{"location":"development/system/concurrency/#direct-merge","text":"A direct merge takes the form of target.apply_merge(source) and copies anything in source that is not in target . In our previous example, a direct merge of R 1 into O 1 would preserve T 1 because it would only add the analysis result R 1 and do nothing else. Likewise, if R 1 finished first, then a direct merge of R 2 O 1 would add T 1 into O 1 because T 1 does not exist in the target. There is another scenario that requires additional logic to handle. Consider the following: root analysis object Z 1 contains observable O 1 . Two different analysis modules A 1 and A 2 are registered to analyze O 1 . Both analysis modules operate independently. A 1 finishes first and adds analysis result R 1 to O 1 , but also changes the analysis_mode property of Z 1 from analysis to correlation . This change to Z 1 is a side effect . A 2 finishes second and adds analysis result R 2 to O 1 . However, it does not change the analysis_mode property of Z 1 . At this point, the core system has no idea if A 2 left the property alone or if it changed it back .","title":"Direct Merge"},{"location":"development/system/concurrency/#differential-merge","text":"A differential merge applies the changes (delta) between two objects to a target object. It takes the form of target.apply_diff_merge(before, after) where target is the object to receive the changes, before is the state of the object before the changes were made, and after is the state of the object after the changes were made. If we apply this to the previous scenario, the differential merge would see that the analysis_mode property was the same in both the before and after objects, so R 2 would not overwrite the property with the wrong value.","title":"Differential Merge"},{"location":"development/system/serialization/","text":"Serialization \u00b6 Data is tracked by the core system in JSON format. The schema of the JSON data is defined in ace/data_model.py by using the pydantic library. The data model is separate from the classes that use them. Each class defined here has a corresponding class. For example, ace.data_model.DetectionPointModel is the data model for ace.analysis.DetectionPoint . The models are used to translate between Python objects, JSON strings, and vice versa. Every Python class that has a corresponding data model defines a to_dict() and to_json() function, as well as class methods for from_dict() and from_json() . The JSON encoder defined for the pydantic library is used to encode and decode complex data types such as dates. Therefore, always use the to_json() and from_json() functions to translate rather than using import json .","title":"Serialization"},{"location":"development/system/serialization/#serialization","text":"Data is tracked by the core system in JSON format. The schema of the JSON data is defined in ace/data_model.py by using the pydantic library. The data model is separate from the classes that use them. Each class defined here has a corresponding class. For example, ace.data_model.DetectionPointModel is the data model for ace.analysis.DetectionPoint . The models are used to translate between Python objects, JSON strings, and vice versa. Every Python class that has a corresponding data model defines a to_dict() and to_json() function, as well as class methods for from_dict() and from_json() . The JSON encoder defined for the pydantic library is used to encode and decode complex data types such as dates. Therefore, always use the to_json() and from_json() functions to translate rather than using import json .","title":"Serialization"},{"location":"development/system/subsystems/","text":"Core Subsystems \u00b6 Implementations \u00b6 The core library contains some default implementations of the subsystems for various usages. Threaded \u00b6 The threaded system defined in ace.system.threaded is a simple implementation that: assumes the entire system runs in a single process under multiple threads tracks all data in in-memory data structures It is used for unit testing and one-off command line analysis. Process \u00b6 Defined in ace.system.process and similar to the threaded system but uses actual system processes instead. Used for command line analysis that needs to use the full CPU capacity of the system. Database \u00b6 Defined in ace.system.database . Uses SQLalchemy to track data. The schema of the database tables are defined in ace.database.schema . Used by both the cli and the distributed system. Distributed \u00b6 A distributed system interface defined in ace.system.distributed that uses FastAPI to expose specific core API functions to external systems. The distributed subsystem can be used to implement a highly scalable ACE core system. Remote \u00b6 A partial system that uses a distributed system running somewhere else. Only the functions exposed by the distributed system are implemented in this system. This system is used by the Analysis Module Manager to communicate with a remote core system. Core Subsystem Composition \u00b6 The ACE core can be composed of any combination of subsystem implementations. They can be mixed in whatever combination is required. Each subsystem has no dependency on another except through the core system API.","title":"Core Subsystems"},{"location":"development/system/subsystems/#core-subsystems","text":"","title":"Core Subsystems"},{"location":"development/system/subsystems/#implementations","text":"The core library contains some default implementations of the subsystems for various usages.","title":"Implementations"},{"location":"development/system/subsystems/#threaded","text":"The threaded system defined in ace.system.threaded is a simple implementation that: assumes the entire system runs in a single process under multiple threads tracks all data in in-memory data structures It is used for unit testing and one-off command line analysis.","title":"Threaded"},{"location":"development/system/subsystems/#process","text":"Defined in ace.system.process and similar to the threaded system but uses actual system processes instead. Used for command line analysis that needs to use the full CPU capacity of the system.","title":"Process"},{"location":"development/system/subsystems/#database","text":"Defined in ace.system.database . Uses SQLalchemy to track data. The schema of the database tables are defined in ace.database.schema . Used by both the cli and the distributed system.","title":"Database"},{"location":"development/system/subsystems/#distributed","text":"A distributed system interface defined in ace.system.distributed that uses FastAPI to expose specific core API functions to external systems. The distributed subsystem can be used to implement a highly scalable ACE core system.","title":"Distributed"},{"location":"development/system/subsystems/#remote","text":"A partial system that uses a distributed system running somewhere else. Only the functions exposed by the distributed system are implemented in this system. This system is used by the Analysis Module Manager to communicate with a remote core system.","title":"Remote"},{"location":"development/system/subsystems/#core-subsystem-composition","text":"The ACE core can be composed of any combination of subsystem implementations. They can be mixed in whatever combination is required. Each subsystem has no dependency on another except through the core system API.","title":"Core Subsystem Composition"}]}