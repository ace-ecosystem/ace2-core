# vim: ts=4:sw=4:et:cc=120
import hashlib

from typing import Union, Optional

from ace.analysis import Observable, AnalysisModuleType
from ace.system import ACESystemInterface, get_system, get_logger
from ace.system.analysis_module import AnalysisModuleType
from ace.system.analysis_request import AnalysisRequest
from ace.system.constants import EVENT_CACHE_NEW
from ace.system.events import fire_event


def generate_cache_key(observable: Observable, amt: AnalysisModuleType) -> str:
    """Returns the key that should be used for caching the result of the
    analysis generated by this analysis module type against this observable."""
    if observable is None:
        return None

    if amt is None:
        return None

    # if the cache_ttl is None then caching is disabled (this is the default behavior)
    if amt.cache_ttl is None:
        return None

    h = hashlib.sha256()
    h.update(observable.type.encode("utf8", errors="ignore"))
    h.update(observable.value.encode("utf8", errors="ignore"))
    if observable.time:
        h.update(str(observable.time.timestamp()).encode("utf8", errors="ignore"))

    h.update(amt.name.encode("utf8", errors="ignore"))
    h.update(amt.version.encode("utf8", errors="ignore"))

    for key in sorted(amt.extended_version):
        h.update(key.encode("utf8", errors="ignore"))

    return h.hexdigest()


class CachingInterface(ACESystemInterface):
    def get_cached_analysis_result(self, cache_key: str) -> Union[AnalysisRequest, None]:
        """Returns the cached AnalysisRequest for the analysis with the given cache key, or None if it does not exist."""
        raise NotImplementedError()

    def cache_analysis_result(self, cache_key: str, request: AnalysisRequest, expiration: Optional[int]) -> str:
        """Caches the AnalysisRequest to the cache key and returns the cache id."""
        raise NotImplementedError()

    def delete_expired_cached_analysis_results(self):
        """Deletes all cache results that have expired."""
        raise NotImplementedError()

    def delete_cached_analysis_results_by_module_type(self, amt: AnalysisModuleType):
        """Deletes all cache results for the given type."""
        raise NotImplementedError()

    #
    # instrumentation
    #

    def get_cache_size(self, amt: Optional[AnalysisModuleType] = None) -> int:
        """Returns the total number of cached results. If no type is specified
        then the total size of all cached results are returned.  Otherwise the
        total size of all cached results for the given type are returned."""
        raise NotImplementedError()


def get_cached_analysis_result(observable: Observable, amt: AnalysisModuleType) -> Union[AnalysisRequest, None]:
    cache_key = generate_cache_key(observable, amt)
    if cache_key is None:
        return None

    return get_system().caching.get_cached_analysis_result(cache_key)


def cache_analysis_result(request: AnalysisRequest) -> Union[str, None]:
    assert isinstance(request, AnalysisRequest)
    assert request.is_observable_analysis_result

    cache_key = generate_cache_key(request.observable, request.type)
    if cache_key is None:
        return None

    get_logger().debug(f"caching analysis request {request} with key {cache_key} ttl {request.type.cache_ttl}")
    result = get_system().caching.cache_analysis_result(cache_key, request, request.type.cache_ttl)
    fire_event(EVENT_CACHE_NEW, [cache_key, request])
    return result


def delete_expired_cached_analysis_results():
    get_logger().debug(f"deleting expired cached analysis results")
    get_system().caching.delete_expired_cached_analysis_results()


def delete_cached_analysis_results_by_module_type(amt: AnalysisModuleType):
    get_logger().debug(f"deleting cached analysis results for analysis module type {amt}")
    get_system().caching.delete_cached_analysis_results_by_module_type(amt)


#
# instrumentation
#


def get_total_cache_size(amt: Optional[AnalysisModuleType] = None):
    return get_system().caching.get_total_cache_size(amt)
